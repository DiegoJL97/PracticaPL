package practicapl;
import java_cup.runtime.*;
import java.util.ArrayList;

parser code 
{:
	ArrayList<String> constantes = new ArrayList();
:}

/* TERMINALES */

terminal String 		numeric_real_const, numeric_integer_const, string_const;
terminal String		 	identifier;
terminal 				unit, program, semicolon, dot, begin, end, constant, equal, var, colon;
terminal 				comma, procedure, function, openParenthesis, closeParenthesis;
terminal 				INTEGER, REAL, assig, plus, minus, multiplication, div, mod;

terminal 				or,and,greater,less,lessEqual,greaterEqual,not;
terminal				ifConditional,then,elseConditional,whileLoop,doFor,repeat,until,forLoop,to,downto;

/* NO TERMINALES */

non terminal String 	DEFCTE, CTELIST, FORMAL_PARAM, FORMAL_PARAMLIST;
non terminal 			PRG;
non terminal            BLQ, DCLLIST, SENTLIST, DCL, SENT, DEFVAR, DEFPROC, DEFFUN;
non terminal			SIMPVALUE, DEFVARLIST, VARLIST, TBAS;
non terminal			ASIG, PROC_CALL, ID, EXP, OP, FACTOR, OPARIT, SUBPARAMLIST, EXPLIST;

non terminal 			EXPCOND, OPLOG, FACTORCOND, OPCOMP, INC;

precedence left identifier;
precedence left plus, minus, multiplication, div, mod, equal;
precedence left not,or,and,equal,greater,less,lessEqual,greaterEqual;
precedence left openParenthesis, closeParenthesis;
precedence left or,and;

/* GRAMATICA */

PRG::= program identifier semicolon BLQ dot {: for(int i=0; i<constantes.size();i++){ System.out.println(constantes.get(i)); } :} | unit identifier semicolon DCLLIST dot;
BLQ::= DCLLIST begin SENTLIST end;
DCLLIST::= DCLLIST DCL | ;
SENTLIST::= SENT | SENTLIST SENT;

DCL::= DEFVAR | DEFCTE:valor {: constantes.add(valor); :}| DEFPROC:valor {: System.out.println(valor); :}| DEFFUN:valor {: System.out.println(valor); :};
DEFVAR::= var DEFVARLIST semicolon;
DEFVARLIST::= VARLIST colon TBAS | DEFVARLIST semicolon VARLIST colon TBAS;
VARLIST::= identifier:id {: RESULT = new String(id); :}| identifier comma VARLIST;
TBAS::= INTEGER {: RESULT = new String("int"); :}| REAL {: RESULT = new String("float"); :};
DEFCTE::= constant CTELIST:valor {: RESULT = new String("#define "+valor); :};
CTELIST::= identifier:id equal SIMPVALUE:valor semicolon {: RESULT = new String(id+" "+valor); :} | CTELIST:valorc identifier:id equal SIMPVALUE:valor semicolon {: RESULT = new String(valorc+" "+id+" "+valor); :};
SIMPVALUE::= numeric_integer_const:i {: RESULT = Integer.parseInt(i); :}
				| numeric_real_const:r {: RESULT = Float.parseFloat(r); :}
				| string_const:st {: RESULT = new String(st); :};
DEFPROC::= procedure identifier:id FORMAL_PARAMLIST:valorf semicolon BLQ semicolon {: RESULT = new String("void "+id+" "+valorf); :};
FORMAL_PARAMLIST::= openParenthesis FORMAL_PARAM:valor closeParenthesis {: RESULT = new String("("+valor+")"); :} | {: RESULT = new String("(void)"); :} ;
FORMAL_PARAM::= VARLIST:valorv colon TBAS:valort {: RESULT = new String(valort+" "+valorv); :}| VARLIST:valorv colon TBAS:valort semicolon FORMAL_PARAM:fp {: RESULT = new String(valort+" "+valorv+", "+fp); :};
DEFFUN::= function identifier:id FORMAL_PARAMLIST:valorf colon TBAS:valorv semicolon BLQ semicolon {: RESULT = new String(valorv+" "+id+" "+valorf); :};

SENT ::= ASIG semicolon | PROC_CALL semicolon | ifConditional EXPCOND then BLQ elseConditional BLQ | whileLoop EXPCOND doFor BLQ | repeat BLQ until EXPCOND semicolon | forLoop identifier assig EXP INC EXP doFor BLQ;
INC ::= to | downto;
ASIG ::= ID assig EXP;
ID ::= identifier;
EXP ::= EXP OP EXP | FACTOR;
OP ::= OPARIT;
OPARIT ::= plus | minus | multiplication | div | mod;
FACTOR ::= SIMPVALUE | openParenthesis EXP closeParenthesis | identifier SUBPARAMLIST;
SUBPARAMLIST ::= openParenthesis EXPLIST closeParenthesis | ;
EXPLIST ::= EXP | EXP comma EXPLIST;
PROC_CALL ::= identifier SUBPARAMLIST;

/*SENTENCIAS DE CONTROL DE FLUJO*/

EXPCOND ::= EXPCOND OPLOG EXPCOND | FACTORCOND;
OPLOG ::= or | and ;
FACTORCOND ::= EXP OPCOMP EXP | openParenthesis EXP closeParenthesis | not FACTORCOND;
OPCOMP ::= less | greater | lessEqual | greaterEqual | equal;
